(function(){'use strict';class a{static userFunctions(b){return new Set(a._deepFunctions(b).filter((a)=>'constructor'!==a&&'fire'!==a&&'_'!==a[0]))}static _deepFunctions(b){if(!b||b===Object.prototype)return[];const c=Object.getOwnPropertyNames(b),d=c.filter((a)=>{const c=Object.getOwnPropertyDescriptor(b,a);return!!c&&'function'==typeof c.value}),e=a._deepFunctions(Object.getPrototypeOf(b));return[...d,...e]}}class b{static getRandomId(){let a=new Uint32Array(1);return crypto.getRandomValues(a),a[0]}}class c{static async Client(a,b,d='*'){return new Promise((e,f)=>{let g=!1;const h=(f)=>{f.source!==a||'OK'!==f.data.status||f.data.interfaceName!==b||'*'!==d&&f.origin!==d||(self.removeEventListener('message',h),g=!0,e(new(c._Client(a,d,b,f.data.result))))};self.addEventListener('message',h);let i;const j=setTimeout(()=>{f(new Error('Connection timeout')),clearTimeout(i)},1e4),k=()=>{if(g)return void clearTimeout(j);try{a.postMessage({command:'getRpcInterface',interfaceName:b,id:0},d)}catch(a){console.log('postMessage failed:'+a)}i=setTimeout(k,1e3)};i=setTimeout(k,100)})}static _Client(a,c,d,e){const f=class{constructor(){this.availableMethods=e,this._targetWindow=a,this._targetOrigin=c,this._waiting=new Map,self.addEventListener('message',this._receive.bind(this))}close(){self.removeEventListener('message',this._receive.bind(this))}_receive({source:a,origin:b,data:c}){if(a===this._targetWindow&&c.status&&c.interfaceName===d&&('*'===this._targetOrigin||b===this._targetOrigin)){const a=this._waiting.get(c.id);if(!a)console.log('Unknown reply',c);else if(this._waiting.delete(c.id),'OK'===c.status)a.resolve(c.result);else if('error'===c.status){const{message:b,stack:d,code:e}=c.result,f=new Error(b);f.code=e,f.stack=d,a.error(f)}}}_invoke(a,c=[]){return new Promise((e,f)=>{const g={command:a,interfaceName:d,args:c,id:b.getRandomId()};this._waiting.set(g.id,{resolve:e,error:f}),this._targetWindow.postMessage(g,'*')})}};for(const b of e)f.prototype[b]=function(...a){return this._invoke(b,a)};return f}static Server(a,b){return new(c._Server(a,b))}static _Server(b,c){const d=class extends b{constructor(){super(),this._name=d.prototype.__proto__.constructor.name,self.addEventListener('message',this._receive.bind(this))}close(){self.removeEventListener('message',this._receive.bind(this))}_replyTo(a,b,c){a.source.postMessage({status:b,result:c,interfaceName:this._name,id:a.data.id},a.origin)}_receive(a){try{if(a.data.interfaceName!==this._name)return;let b=a.data.args||[];c&&'getRpcInterface'!==a.data.command&&(b=[{callingWindow:a.source,callingOrigin:a.origin},...b]);const d=this._invoke(a.data.command,b);d instanceof Promise?d.then((b)=>this._replyTo(a,'OK',b)).catch((b)=>this._replyTo(a,'error',b.message?{message:b.message,stack:b.stack,code:b.code}:{message:b})):this._replyTo(a,'OK',d)}catch(b){this._replyTo(a,'error',b.message?{message:b.message,stack:b.stack,code:b.code}:{message:b})}}_invoke(a,b){return this[a].apply(this,b)}};d.prototype._rpcInterface=[];for(const e of a.userFunctions(b.prototype))d.prototype._rpcInterface.push(e);return d.prototype._rpcInterface.push('getRpcInterface'),d.prototype.getRpcInterface=function(){return this.onConnected&&this.onConnected.call(this),d.prototype._rpcInterface},d}}class d{constructor(){this._listeners=new Map;const a=this;c.Server(class{on({callingWindow:b,callingOrigin:c},d){a._listeners.get(d)||a._listeners.set(d,new Map),a._listeners.get(d).set(b,c)}off({callingWindow:b,callingOrigin:c},d){const e=a._listeners.get(d);e.get(b)!==c||(e.delete(b),0===a._listeners.get(d).length&&a._listeners.delete(d))}onConnected(){a.onConnected()}},!0)}fire(a,b){if(this._listeners.get(a))for(const[c,d]of this._listeners.get(a))c.postMessage({event:a,value:b},d)}onConnected(){}}class f{static get API_URL(){return'/dist/nimiq.js'}static get satoshis(){return 1e5}static getApi(){return this._api=this._api||new f,this._api}constructor(){this._apiInitialized=new Promise(async(a)=>{await f._importApi(),await Nimiq.load(),a()}),this._createConsensusPromise(),this._balances=new Map}async connect(){await this._apiInitialized,Nimiq.GenesisConfig.bounty(),this._consensus=await Nimiq.Consensus.volatileNano(),this._consensus.on('syncing',()=>this._onConsensusSyncing()),this._consensus.on('established',()=>this.__consensusEstablished()),this._consensus.on('lost',()=>this._consensusLost()),this._consensus.network.connect(),this._consensus.blockchain.on('head-changed',(a)=>this._headChanged(a.header)),this._consensus.mempool.on('transaction-added',(a)=>this._transactionAdded(a)),this._consensus.mempool.on('transaction-mined',(a,b)=>this._transactionMined(a,b)),this._consensus.network.on('peers-changed',()=>this._onPeersChanged())}async _headChanged(a){if(this._consensus.established){const b=await this._getBalances([...this._balances.keys()]);for(const[a,c]of b){if(this._balances.get(a)===c){b.delete(a);continue}this._balances.set(a,c)}b.size&&this._onBalancesChanged(b),this._onHeadChange(a)}}async _getAccounts(a,b){if(0===a.length)return[];await this._consensusEstablished;let c;const d=a.map((a)=>Nimiq.Address.fromUserFriendlyAddress(a));try{c=await this._consensus.getAccounts(d)}catch(c){return b=b||0,b++,await new Promise((c)=>{const d=1e3*b;setTimeout(async()=>{c((await this._getAccounts(a,b)))},d),console.warn(`Could not retrieve accounts from consensus, retrying in ${d/1e3} s`)})}return c}async _subscribeAddresses(a){a.forEach((a)=>this._balances.set(a,0));const b=a.map((a)=>Nimiq.Address.fromUserFriendlyAddress(a));await this._consensusEstablished,this._consensus.subscribeAccounts(b)}async _getBalances(a){let b=await this._getAccounts(a);const c=new Map;return b.forEach((b,d)=>{const e=a[d],g=b?b.balance/f.satoshis:0;c.set(e,g)}),c}async _requestTransactionHistory(a,b=new Map,c=0){await this._consensusEstablished,a=Nimiq.Address.fromUserFriendlyAddress(a);let d=await this._consensus._requestTransactionReceipts(a);const e=[...b.keys()];d=d.filter((a)=>{if(a.blockHeight<c)return!1;const d=a.transactionHash.toBase64();return!e.includes(d)||a.blockHash.toBase64()!==b.get(d)});const g=[];let h=null;for(const i of d)if(!i.blockHash.equals(h)){const a=await this._consensus._blockchain.getBlock(i.blockHash);if(a)g.push(Promise.resolve(a));else{const a=this._consensus._requestBlockProof(i.blockHash,i.blockHeight).catch((a)=>console.error(f,`Failed to retrieve proof for block ${i.blockHash}`+` (${a.message||a}) - transaction history may be incomplete`));g.push(a)}h=i.blockHash}const i=await Promise.all(g),j=[];for(const d of i){if(!d)continue;const b=this._consensus._requestTransactionsProof([a],d).then((a)=>a.map((a)=>({transaction:a,header:d.header}))).catch((a)=>console.error(f,`Failed to retrieve transactions for block ${d.hash}`+` (${a.message||a}) - transaction history may be incomplete`));j.push(b)}const k=await Promise.all(j);return k.reduce((a,b)=>b?a.concat(b):a,[]).sort((c,a)=>c.header.height-a.header.height)}__consensusEstablished(){this._consensusEstablishedResolver(),this._headChanged(this._consensus.blockchain.head),this._onConsensusEstablished()}_consensusLost(){this._createConsensusPromise(),this._onConsensusLost()}_transactionAdded(a){const b=a.recipient.toUserFriendlyAddress(),c=a.sender.toUserFriendlyAddress(),d=new Set(this._balances.keys());(d.has(c)||d.has(b))&&this._onTransactionPending(c,b,a.value/f.satoshis,a.fee/f.satoshis,a.hash().toBase64())}_transactionMined(a,b){const c=a.recipient.toUserFriendlyAddress(),d=a.sender.toUserFriendlyAddress(),e=new Set(this._balances.keys());(e.has(c)||e.has(d))&&this._onTransactionMined(d,c,a.value/f.satoshis,a.fee/f.satoshis,a.hash().toBase64(),b.height,b.timestamp)}_createConsensusPromise(){this._consensusEstablished=new Promise((a)=>{this._consensusEstablishedResolver=a})}_globalHashrate(a){return Math.round(65536*a/Nimiq.Policy.BLOCK_TIME)}async relayTransaction(a){await this._consensusEstablished;const b=Nimiq.PublicKey.unserialize(Nimiq.SerialBuffer.from(a.senderPubKey)),c=Nimiq.Address.fromUserFriendlyAddress(a.recipient),d=Nimiq.Policy.coinsToSatoshis(a.value),e=Nimiq.Policy.coinsToSatoshis(a.fee),f=parseInt(a.validityStartHeight),g=Nimiq.Signature.unserialize(Nimiq.SerialBuffer.from(a.signature)),h=new Nimiq.BasicTransaction(b,c,d,e,f,g);return this._consensus.relayTransaction(h)}async subscribe(a){a instanceof Array||(a=[a]),this._subscribeAddresses(a);const b=await this._getBalances(a);for(const[c,d]of b)this._balances.set(c,d);this._onBalancesChanged(b)}getBalance(a){a instanceof Array||(a=[a]);const b=this._getBalances(a);for(const[c,d]of b)this._balances.set(c,d);return b}async getAccountTypeString(a){const b=(await this._getAccounts([a]))[0];if(!b)return'basic';switch(b.type){case Nimiq.Account.Type.BASIC:return'basic';case Nimiq.Account.Type.VESTING:return'vesting';case Nimiq.Account.Type.HTLC:return'htlc';default:return!1;}}async requestTransactionHistory(a,b,c){a instanceof Array||(a=[a]);let d=await Promise.all(a.map((a)=>this._requestTransactionHistory(a,b,c)));return d=d.reduce((a,b)=>b?a.concat(b):a,[]),d=d.map((a)=>({sender:a.transaction.sender.toUserFriendlyAddress(),recipient:a.transaction.recipient.toUserFriendlyAddress(),value:a.transaction.value/f.satoshis,fee:a.transaction.fee/f.satoshis,hash:a.transaction.hash().toBase64(),blockHeight:a.header.height,blockHash:a.header.hash().toBase64(),timestamp:a.header.timestamp})),d}async getGenesisVestingContracts(){await this._apiInitialized;const a=[],b=Nimiq.BufferUtils.fromBase64(Nimiq.GenesisConfig.GENESIS_ACCOUNTS),c=b.readUint16();for(let d=0;d<c;d++){const c=Nimiq.Address.unserialize(b),d=Nimiq.Account.unserialize(b);1===d.type&&a.push({address:c.toUserFriendlyAddress(),owner:d.owner.toUserFriendlyAddress(),start:d.vestingStart,stepAmount:d.vestingStepAmount/f.satoshis,stepBlocks:d.vestingStepBlocks,totalAmount:d.vestingTotalAmount/f.satoshis})}return a}_onInitialized(){this.fire('nimiq-api-ready')}_onConsensusSyncing(){this.fire('nimiq-consensus-syncing')}_onConsensusEstablished(){this.fire('nimiq-consensus-established')}_onConsensusLost(){this.fire('nimiq-consensus-lost')}_onBalancesChanged(a){this.fire('nimiq-balances',a)}_onTransactionPending(a,b,c,d,e){this.fire('nimiq-transaction-pending',{sender:a,recipient:b,value:c,fee:d,hash:e})}_onTransactionMined(a,b,c,d,e,f,g){this.fire('nimiq-transaction-mined',{sender:a,recipient:b,value:c,fee:d,hash:e,blockHeight:f,timestamp:g})}_onDifferentTabError(a){this.fire('nimiq-different-tab-error',a)}_onInitializationError(a){this.fire('nimiq-api-fail',a)}_onHeadChange(a){this.fire('nimiq-head-change',{height:a.height,globalHashrate:this._globalHashrate(a.difficulty)})}_onPeersChanged(){this.fire('nimiq-peer-count',this._consensus.network.peerCount)}static _importApi(){return new Promise((a,b)=>{let c=document.createElement('script');c.type='text/javascript',c.src=f.API_URL,c.addEventListener('load',()=>a(c),!1),c.addEventListener('error',()=>b(c),!1),document.body.appendChild(c)})}fire(){throw new Error('The fire() method needs to be overloaded!')}}new class{constructor(){this.connect()}async connect(){const a=new d,b=c.Server(f);b.fire=(b,c)=>a.fire(b,c),await b.connect()}}})();
//# sourceMappingURL=app.min.js.map
