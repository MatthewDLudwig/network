{"version":3,"sources":["app.min.js","../secure-utils/reflection/reflection.js","../secure-utils/random/random.js","../boruca-messaging/src/rpc.js","../boruca-messaging/src/event-server.js","../nano-api/nano-network-api.js","network.js"],"names":["userFunctions","Set","_deepFunctions","filter","Object","prototype","getOwnPropertyNames","getOwnPropertyDescriptor","value","getPrototypeOf","getRandomId","Uint32Array","crypto","getRandomValues","Client","Promise","source","data","status","interfaceName","origin","self","removeEventListener","_Client","result","addEventListener","setTimeout","Error","clearTimeout","postMessage","command","id","console","log","constructor","availableMethods","_targetWindow","_targetOrigin","_waiting","Map","_receive","bind","close","get","delete","resolve","message","stack","code","error","_invoke","args","set","Server","_Server","_name","__proto__","name","_replyTo","callingWindow","callingOrigin","then","catch","apply","_rpcInterface","push","onConnected","call","_listeners","on","off","length","fire","event","API_URL","satoshis","getApi","_api","_apiInitialized","_importApi","Nimiq","load","_createConsensusPromise","_balances","connect","GenesisConfig","bounty","_consensus","Consensus","volatileNano","_onConsensusSyncing","__consensusEstablished","_consensusLost","network","blockchain","_headChanged","header","mempool","_transactionAdded","_transactionMined","_onPeersChanged","established","_getBalances","keys","size","_onBalancesChanged","_onHeadChange","_getAccounts","_consensusEstablished","map","Address","fromUserFriendlyAddress","getAccounts","warn","_subscribeAddresses","forEach","subscribeAccounts","balance","_requestTransactionHistory","_requestTransactionReceipts","blockHeight","transactionHash","toBase64","includes","blockHash","equals","_blockchain","getBlock","_requestBlockProof","all","_requestTransactionsProof","transaction","hash","reduce","concat","sort","height","_consensusEstablishedResolver","head","_onConsensusEstablished","_onConsensusLost","recipient","toUserFriendlyAddress","sender","has","_onTransactionPending","fee","_onTransactionMined","timestamp","_globalHashrate","Math","round","Policy","BLOCK_TIME","relayTransaction","PublicKey","unserialize","SerialBuffer","from","senderPubKey","coinsToSatoshis","parseInt","validityStartHeight","Signature","signature","BasicTransaction","subscribe","Array","getBalance","getAccountTypeString","type","Account","Type","BASIC","VESTING","HTLC","requestTransactionHistory","getGenesisVestingContracts","BufferUtils","fromBase64","GENESIS_ACCOUNTS","readUint16","address","owner","start","vestingStart","stepAmount","vestingStepAmount","stepBlocks","vestingStepBlocks","totalAmount","vestingTotalAmount","_onInitialized","_onDifferentTabError","_onInitializationError","globalHashrate","difficulty","peerCount","document","createElement","src","body","appendChild"],"mappings":"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","file":"app.min.js","sourcesContent":["(function () {\n'use strict';\n\nclass Reflection {\n    /** @param {Object} proto\n     *\n     * @returns {Set<string>}\n     */\n    static userFunctions(proto) {\n        return new Set(Reflection._deepFunctions(proto).filter(name => {\n            return name !== 'constructor'\n                && name !== 'fire'\n                && name[0] !== '_';\n        }));\n    }\n\n    /** @param {Object} proto\n     *\n     * @returns {string[]}\n     */\n    static _deepFunctions(proto) {\n        if (!proto || proto === Object.prototype) return [];\n\n        const ownProps = Object.getOwnPropertyNames(proto);\n\n        const ownFunctions = ownProps.filter(name => {\n            const desc = Object.getOwnPropertyDescriptor(proto, name);\n            return !!desc && typeof desc.value === 'function';\n        });\n\n        const deepFunctions = Reflection._deepFunctions(Object.getPrototypeOf(proto));\n\n        return [...ownFunctions, ...deepFunctions];\n    }\n}\n\nclass Random {\n    static getRandomId() {\n        let array = new Uint32Array(1);\n        crypto.getRandomValues(array);\n        return array[0];\n    }\n}\n\nclass RPC {\n    /**\n     * @param {Window} targetWindow\n     * @param {string} interfaceName\n     * @param {string} [targetOrigin]\n     * @returns {Promise}\n     */\n    static async Client(targetWindow, interfaceName, targetOrigin = '*') {\n        return new Promise((resolve, reject) => {\n            let connected = false;\n\n            const interfaceListener = (message) => {\n                if (message.source !== targetWindow\n                    || message.data.status !== 'OK'\n                    || message.data.interfaceName !== interfaceName\n                    || (targetOrigin !== '*' && message.origin !== targetOrigin)) return;\n\n                self.removeEventListener('message', interfaceListener);\n\n                connected = true;\n\n                resolve( new (RPC._Client(targetWindow, targetOrigin, interfaceName, message.data.result))() );\n            };\n\n            self.addEventListener('message', interfaceListener);\n\n\n            let connectTimer;\n            const timeoutTimer = setTimeout(() => {\n                reject(new Error('Connection timeout'));\n                clearTimeout(connectTimer);\n            }, 10000);\n\n            const tryToConnect = () => {\n                if (connected) {\n                    clearTimeout(timeoutTimer);\n                    return;\n                }\n\n                try {\n                    targetWindow.postMessage({ command: 'getRpcInterface', interfaceName, id: 0 }, targetOrigin);\n                } catch (e){\n                    console.log('postMessage failed:' + e);\n                }\n                connectTimer = setTimeout(tryToConnect, 1000);\n            };\n\n            connectTimer = setTimeout(tryToConnect, 100);\n        });\n    }\n\n\n    /**\n     * @param {Window} targetWindow\n     * @param {string} interfaceName\n     * @param {array} functionNames\n     * @returns {Class}\n     * @private\n     */\n    static _Client(targetWindow, targetOrigin, interfaceName, functionNames) {\n        const Client = class {\n            constructor() {\n                this.availableMethods = functionNames;\n                // Svub: Code smell that _targetWindow and _waiting are visible outside. Todo later!\n                /** @private\n                 *  @type {Window} */\n                this._targetWindow = targetWindow;\n                this._targetOrigin = targetOrigin;\n                /** @private\n                 *  @type {Map.<number,{resolve:Function,error:Function}>} */\n                this._waiting = new Map();\n                self.addEventListener('message', this._receive.bind(this));\n            }\n\n            close() {\n                self.removeEventListener('message', this._receive.bind(this));\n            }\n\n            _receive({ source, origin, data }) {\n                // Discard all messages from unwanted sources\n                // or which are not replies\n                // or which are not from the correct interface\n                if (source !== this._targetWindow\n                    || !data.status\n                    || data.interfaceName !== interfaceName\n                    || (this._targetOrigin !== '*' && origin !== this._targetOrigin)) return;\n\n                const callback = this._waiting.get(data.id);\n\n                if (!callback) {\n                    console.log('Unknown reply', data);\n                } else {\n                    this._waiting.delete(data.id);\n\n                    if (data.status === 'OK') {\n                        callback.resolve(data.result);\n                    } else if (data.status === 'error') {\n                        const { message, stack, code } = data.result;\n                        const error = new Error(message);\n                        error.code = code;\n                        error.stack = stack;\n                        callback.error(error);\n                    }\n                }\n            }\n\n            /**\n             * @param {string} command\n             * @param {object[]} [args]\n             * @returns {Promise}\n             * @private\n             */\n            _invoke(command, args = []) {\n                return new Promise((resolve, error) => {\n                    const obj = { command, interfaceName, args, id: Random.getRandomId() };\n                    this._waiting.set(obj.id, { resolve, error });\n                    this._targetWindow.postMessage(obj, '*');\n                    // no timeout for now, as some actions require user interactions\n                    // todo maybe set timeout via parameter?\n                    //setTimeout(() => error(new Error ('request timeout')), 10000);\n                });\n            }\n        };\n\n        for (const functionName of functionNames) {\n            Client.prototype[functionName] = function (...args) {\n                return this._invoke(functionName, args);\n            };\n        }\n\n        return Client;\n    }\n\n    /**\n     * @param {Class} clazz: The class whose methods will be made available via postMessage RPC\n     * @param {boolean} useAccessControl: If set, message.source and message.origin will be passed as first two arguments to each method.\n     * @return {T extends clazz}\n     */\n    static Server(clazz, useAccessControl) {\n        return new (RPC._Server(clazz, useAccessControl))();\n    }\n\n    static _Server(clazz, useAccessControl) {\n        const Server = class extends clazz {\n            constructor() {\n                super();\n                this._name = Server.prototype.__proto__.constructor.name;\n                self.addEventListener('message', this._receive.bind(this));\n            }\n\n            close() {\n                self.removeEventListener('message', this._receive.bind(this));\n            }\n\n            _replyTo(message, status, result) {\n                message.source.postMessage({ status, result, interfaceName: this._name, id: message.data.id }, message.origin);\n            }\n\n            _receive(message) {\n                try {\n                    if (message.data.interfaceName !== this._name) return;\n\n                    let args = message.data.args || [];\n\n                    if (useAccessControl && message.data.command !== 'getRpcInterface') {\n                        // Inject calling origin to function args\n                        args = [{ callingWindow: message.source, callingOrigin: message.origin }, ...args];\n                    }\n\n                    /* deactivate this since there is no security issue and by wrapping in acl length info gets lost\n                    // Test if request calls an existing method with the right number of arguments\n                    const calledMethod = this[message.data.command];\n                    if (!calledMethod) {\n                        throw `Non-existing method ${message.data.command} called: ${message}`;\n                    }\n\n                    if (calledMethod.length < args.length) {\n                        throw `Too many arguments passed: ${message}`;\n                    }*/\n\n                    const result = this._invoke(message.data.command, args);\n\n                    if (result instanceof Promise) {\n                        result\n                            .then((finalResult) => this._replyTo(message, 'OK', finalResult))\n                            .catch(e => this._replyTo(message, 'error',\n                                e.message ? { message: e.message, stack: e.stack, code: e.code } : { message: e } ));\n                    } else {\n                        this._replyTo(message, 'OK', result);\n                    }\n                } catch (e) {\n                    this._replyTo(message, 'error',\n                        e.message ? { message: e.message, stack: e.stack, code: e.code } : { message: e } );\n                }\n            }\n\n            _invoke(command, args) {\n                return this[command].apply(this, args);\n            }\n        };\n\n        // Collect function names of the Server's interface\n        Server.prototype._rpcInterface = [];\n        for (const functionName of Reflection.userFunctions(clazz.prototype)) {\n            Server.prototype._rpcInterface.push(functionName);\n        }\n        Server.prototype._rpcInterface.push('getRpcInterface');\n\n        // Add function to retrieve the interface\n        Server.prototype['getRpcInterface'] = function() {\n            if(this.onConnected) this.onConnected.call(this);\n            return Server.prototype._rpcInterface;\n        };\n\n        return Server;\n    }\n}\n\n// TODO: Handle unload/load events (how?)\n\nclass EventServer {\n    constructor() {\n        this._listeners = new Map();\n        const that = this;\n        RPC.Server(class EventRPCServer {\n            on({ callingWindow, callingOrigin }, event) {\n                if (!that._listeners.get(event)) {\n                    that._listeners.set(event, new Map());\n                }\n                that._listeners.get(event).set(callingWindow, callingOrigin);\n            }\n\n            off({ callingWindow, callingOrigin }, event) {\n                const eventEntry = that._listeners.get(event);\n                if (eventEntry.get(callingWindow) !== callingOrigin) return;\n\n                eventEntry.delete(callingWindow);\n                if (that._listeners.get(event).length === 0) {\n                    that._listeners.delete(event);\n                }\n            }\n\n            onConnected() {\n                that.onConnected();\n            }\n        }, true);\n    }\n\n    fire(event, value) {\n        if (!this._listeners.get(event)) return;\n\n        for (const [callingWindow, callingOrigin] of this._listeners.get(event)) {\n            callingWindow.postMessage({event, value}, callingOrigin);\n        }\n    }\n\n    onConnected() { }\n}\n\nclass NanoNetworkApi {\n\n    // static get API_URL() { return 'https://cdn.nimiq-network.com/branches/master/nimiq.js' }\n    /*\n    @asset(/dist/nimiq.js)\n    @asset(/dist/web.js)\n    @asset(/dist/worker.js)\n    @asset(/dist/worker-wasm.js)\n    @asset(/dist/worker-wasm.wasm)\n    */\n    static get API_URL() { return '/dist/nimiq.js' }\n    static get satoshis() { return 1e5 }\n\n    static getApi() {\n        this._api = this._api || new NanoNetworkApi();\n        return this._api;\n    }\n\n    constructor() {\n        this._apiInitialized = new Promise(async (resolve) => {\n            await NanoNetworkApi._importApi();\n            await Nimiq.load();\n            // setTimeout(resolve, 500);\n            resolve();\n        });\n        this._createConsensusPromise();\n\n        this._balances = new Map();\n    }\n\n    async connect() {\n        await this._apiInitialized;\n        Nimiq.GenesisConfig.bounty();\n        this._consensus = await Nimiq.Consensus.volatileNano();\n        this._consensus.on('syncing', e => this._onConsensusSyncing());\n        this._consensus.on('established', e => this.__consensusEstablished());\n        this._consensus.on('lost', e => this._consensusLost());\n\n        // this._consensus.on('sync-finished', e => console.log('consensus sync-finished'));\n        // this._consensus.on('sync-failed', e => console.log('consensus sync-failed'));\n        // this._consensus.on('sync-chain-proof', e => console.log('consensus sync-chain-proof'));\n        // this._consensus.on('verify-chain-proof', e => console.log('consensus verify-chain-proof'));\n\n        this._consensus.network.connect();\n\n        this._consensus.blockchain.on('head-changed', block => this._headChanged(block.header));\n        this._consensus.mempool.on('transaction-added', tx => this._transactionAdded(tx));\n        // this._consensus.mempool.on('transaction-expired', tx => this._transactionExpired(tx));\n        this._consensus.mempool.on('transaction-mined', (tx, header) => this._transactionMined(tx, header));\n        this._consensus.network.on('peers-changed', () => this._onPeersChanged());\n    }\n\n    async _headChanged(header) {\n        if (!this._consensus.established) return;\n        const balances = await this._getBalances([...this._balances.keys()]);\n\n        for (const [address, balance] of balances) {\n            if (this._balances.get(address) === balance) {\n                balances.delete(address);\n                continue;\n            }\n\n            this._balances.set(address, balance);\n        }\n\n        if (balances.size) this._onBalancesChanged(balances);\n\n        this._onHeadChange(header);\n    }\n\n    /**\n     * @returns {Array<Account>} An array element can be NULL if account does not exist\n     */\n    async _getAccounts(addresses, stackHeight) {\n        if (addresses.length === 0) return [];\n        await this._consensusEstablished;\n        let accounts;\n        const addressesAsAddresses = addresses.map(address => Nimiq.Address.fromUserFriendlyAddress(address));\n        try {\n            accounts = await this._consensus.getAccounts(addressesAsAddresses);\n        } catch (e) {\n            stackHeight = stackHeight || 0;\n            stackHeight++;\n            return await new Promise(resolve => {\n                const timeout = 1000 * stackHeight;\n                setTimeout(async _ => {\n                    resolve(await this._getAccounts(addresses, stackHeight));\n                }, timeout);\n                console.warn(`Could not retrieve accounts from consensus, retrying in ${timeout / 1000} s`);\n            });\n        }\n\n        return accounts;\n    }\n\n    /**\n     * @param {Array<string>} addresses\n     */\n    async _subscribeAddresses(addresses) {\n        addresses.forEach(address => this._balances.set(address, 0));\n\n        const addressesAsAddresses = addresses.map(address => Nimiq.Address.fromUserFriendlyAddress(address));\n        await this._consensusEstablished;\n        this._consensus.subscribeAccounts(addressesAsAddresses);\n    }\n\n    /**\n     * @param {Array<string>} addresses\n     * @returns {Map}\n     */\n    async _getBalances(addresses) {\n        let accounts = await this._getAccounts(addresses);\n\n        const balances = new Map();\n\n        accounts.forEach((account, i) => {\n            const address = addresses[i];\n            const balance = account ? account.balance / NanoNetworkApi.satoshis : 0;\n            balances.set(address, balance);\n        });\n\n        return balances;\n    }\n\n    /**\n     * @param {string} address\n     * @param {Map} [knownReceipts] A map with the tx hash as key and the blockhash as value\n     * @param {uint} [fromHeight]\n     */\n    async _requestTransactionHistory(address, knownReceipts = new Map(), fromHeight = 0) {\n        await this._consensusEstablished;\n        address = Nimiq.Address.fromUserFriendlyAddress(address);\n\n        // Inpired by Nimiq.BaseConsensus._requestTransactionHistory()\n\n        // 1. Get transaction receipts.\n        let receipts = await this._consensus._requestTransactionReceipts(address);\n        // console.log(`Received ${receipts.length} receipts from the network.`);\n\n        // 2 Filter out known receipts.\n        const knownTxHashes = [...knownReceipts.keys()];\n\n        receipts = receipts.filter(receipt => {\n            if (receipt.blockHeight < fromHeight) return false;\n\n            const hash = receipt.transactionHash.toBase64();\n\n            // Known transaction\n            if (knownTxHashes.includes(hash)) {\n                // Check if block has changed\n                return receipt.blockHash.toBase64() !== knownReceipts.get(hash);\n            }\n\n            // Unknown transaction\n            return true;\n        });\n        // console.log(`Reduced to ${receipts.length} unknown receipts.`);\n\n        // FIXME TODO: Check for tx that have been removed from the blockchain!\n\n        // 3. Request proofs for missing blocks.\n        /** @type {Array.<Promise.<Block>>} */\n        const blockRequests = [];\n        let lastBlockHash = null;\n        for (const receipt of receipts) {\n            if (!receipt.blockHash.equals(lastBlockHash)) {\n                // eslint-disable-next-line no-await-in-loop\n                const block = await this._consensus._blockchain.getBlock(receipt.blockHash);\n                if (block) {\n                    blockRequests.push(Promise.resolve(block));\n                } else {\n                    const request = this._consensus._requestBlockProof(receipt.blockHash, receipt.blockHeight)\n                        .catch(e => console.error(NanoNetworkApi, `Failed to retrieve proof for block ${receipt.blockHash}`\n                            + ` (${e.message || e}) - transaction history may be incomplete`));\n                    blockRequests.push(request);\n                }\n\n                lastBlockHash = receipt.blockHash;\n            }\n        }\n        const blocks = await Promise.all(blockRequests);\n\n        // 4. Request transaction proofs.\n        const transactionRequests = [];\n        for (const block of blocks) {\n            if (!block) continue;\n\n            const request = this._consensus._requestTransactionsProof([address], block)\n                .then(txs => txs.map(tx => ({ transaction: tx, header: block.header })))\n                .catch(e => console.error(NanoNetworkApi, `Failed to retrieve transactions for block ${block.hash}`\n                    + ` (${e.message || e}) - transaction history may be incomplete`));\n            transactionRequests.push(request);\n        }\n\n        const transactions = await Promise.all(transactionRequests);\n        return transactions\n            .reduce((flat, it) => it ? flat.concat(it) : flat, [])\n            .sort((a, b) => a.header.height - b.header.height);\n    }\n\n    __consensusEstablished() {\n        this._consensusEstablishedResolver();\n        this._headChanged(this._consensus.blockchain.head);\n        this._onConsensusEstablished();\n    }\n\n    _consensusLost() {\n        this._createConsensusPromise();\n        this._onConsensusLost();\n    }\n\n    _transactionAdded(tx) {\n        const recipientAddr = tx.recipient.toUserFriendlyAddress();\n        const senderAddr = tx.sender.toUserFriendlyAddress();\n        const trackedAddresses = new Set(this._balances.keys());\n\n        if (trackedAddresses.has(senderAddr) || trackedAddresses.has(recipientAddr)) {\n            this._onTransactionPending(senderAddr, recipientAddr, tx.value / NanoNetworkApi.satoshis, tx.fee / NanoNetworkApi.satoshis, tx.hash().toBase64());\n        }\n    }\n\n    _transactionMined(tx, header) {\n        const recipientAddr = tx.recipient.toUserFriendlyAddress();\n        const senderAddr = tx.sender.toUserFriendlyAddress();\n        const trackedAddresses = new Set(this._balances.keys());\n\n        if (trackedAddresses.has(recipientAddr) || trackedAddresses.has(senderAddr)) {\n            this._onTransactionMined(senderAddr, recipientAddr, tx.value / NanoNetworkApi.satoshis, tx.fee / NanoNetworkApi.satoshis, tx.hash().toBase64(), header.height, header.timestamp);\n        }\n    }\n\n    _createConsensusPromise() {\n        this._consensusEstablished = new Promise(resolve => {\n            this._consensusEstablishedResolver = resolve;\n        });\n    }\n\n    _globalHashrate(difficulty) {\n        return Math.round(difficulty * Math.pow(2, 16) / Nimiq.Policy.BLOCK_TIME);\n    }\n\n    /*\n        Public API\n\n        @param {Object} obj: {\n            sender: <user friendly address>,\n            senderPubKey: <serialized public key>,\n            recipient: <user friendly address>,\n            value: <value in NIM>,\n            fee: <fee in NIM>,\n            validityStartHeight: <integer>,\n            signature: <serialized signature>\n        }\n    */\n    async relayTransaction(obj) {\n        await this._consensusEstablished;\n        const senderPubKey = Nimiq.PublicKey.unserialize(Nimiq.SerialBuffer.from(obj.senderPubKey));\n        const recipientAddr = Nimiq.Address.fromUserFriendlyAddress(obj.recipient);\n        const value = Nimiq.Policy.coinsToSatoshis(obj.value);\n        const fee = Nimiq.Policy.coinsToSatoshis(obj.fee);\n        const validityStartHeight = parseInt(obj.validityStartHeight);\n        const signature = Nimiq.Signature.unserialize(Nimiq.SerialBuffer.from(obj.signature));\n\n        const tx = new Nimiq.BasicTransaction(senderPubKey, recipientAddr, value, fee, validityStartHeight, signature);\n\n        return this._consensus.relayTransaction(tx);\n    }\n\n    /**\n     * @param {string|Array<string>} addresses\n     */\n    async subscribe(addresses) {\n        if (!(addresses instanceof Array)) addresses = [addresses];\n\n        this._subscribeAddresses(addresses);\n\n        const balances = await this._getBalances(addresses);\n        for (const [address, balance] of balances) { this._balances.set(address, balance); }\n\n        this._onBalancesChanged(balances);\n    }\n\n    /**\n     * @param {string|Array<string>} addresses\n     * @returns {Map}\n     */\n    getBalance(addresses) {\n        if (!(addresses instanceof Array)) addresses = [addresses];\n\n        const balances = this._getBalances(addresses);\n        for (const [address, balance] of balances) { this._balances.set(address, balance); }\n\n        return balances;\n    }\n\n    async getAccountTypeString(address) {\n        const account = (await this._getAccounts([address]))[0];\n\n        if (!account) return 'basic';\n\n        // See Nimiq.Account.Type\n        switch (account.type) {\n            case Nimiq.Account.Type.BASIC: return 'basic';\n            case Nimiq.Account.Type.VESTING: return 'vesting';\n            case Nimiq.Account.Type.HTLC: return 'htlc';\n            default: return false;\n        }\n    }\n\n    async requestTransactionHistory(addresses, knownReceipts, fromHeight) {\n        if (!(addresses instanceof Array)) addresses = [addresses];\n\n        let txs = await Promise.all(addresses.map(address => this._requestTransactionHistory(address, knownReceipts, fromHeight)));\n\n        // txs is an array of arrays of objects, which have the format {transaction: Nimiq.Transaction, header: Nimiq.BlockHeader}\n        // We need to reduce this to usable simple tx objects\n\n        // First, reduce\n        txs = txs.reduce((flat, it) => it ? flat.concat(it) : flat, []);\n\n        // Then map to simple objects\n        txs = txs.map(tx => ({\n            sender: tx.transaction.sender.toUserFriendlyAddress(),\n            recipient: tx.transaction.recipient.toUserFriendlyAddress(),\n            value: tx.transaction.value / NanoNetworkApi.satoshis,\n            fee: tx.transaction.fee / NanoNetworkApi.satoshis,\n            hash: tx.transaction.hash().toBase64(),\n            blockHeight: tx.header.height,\n            blockHash: tx.header.hash().toBase64(),\n            timestamp: tx.header.timestamp\n        }));\n\n        // Finally, sort the array\n        // return txs.sort((a, b) => a.blockHeight - b.blockHeight);\n        return txs; // Sorting is done in transaction-redux\n    }\n\n    async getGenesisVestingContracts() {\n        await this._apiInitialized;\n        const accounts = [];\n        const buf = Nimiq.BufferUtils.fromBase64(Nimiq.GenesisConfig.GENESIS_ACCOUNTS);\n        const count = buf.readUint16();\n        for (let i = 0; i < count; i++) {\n            const address = Nimiq.Address.unserialize(buf);\n            const account = Nimiq.Account.unserialize(buf);\n\n            if (account.type === 1) {\n                accounts.push({\n                    address: address.toUserFriendlyAddress(),\n                    // balance: account.balance / NanoNetworkApi.satoshis,\n                    owner: account.owner.toUserFriendlyAddress(),\n                    start: account.vestingStart,\n                    stepAmount: account.vestingStepAmount / NanoNetworkApi.satoshis,\n                    stepBlocks: account.vestingStepBlocks,\n                    totalAmount: account.vestingTotalAmount / NanoNetworkApi.satoshis\n                });\n            }\n        }\n        return accounts;\n    }\n\n    _onInitialized() {\n        // console.log('Nimiq API ready to use');\n        this.fire('nimiq-api-ready');\n    }\n\n    _onConsensusSyncing() {\n        // console.log('consensus syncing');\n        this.fire('nimiq-consensus-syncing');\n    }\n\n    _onConsensusEstablished() {\n        // console.log('consensus established');\n        this.fire('nimiq-consensus-established');\n    }\n\n    _onConsensusLost() {\n        // console.log('consensus lost');\n        this.fire('nimiq-consensus-lost');\n    }\n\n    _onBalancesChanged(balances) {\n        // console.log('new balances:', balances);\n        this.fire('nimiq-balances', balances);\n    }\n\n    _onTransactionPending(sender, recipient, value, fee, hash) {\n        // console.log('pending:', { sender, recipient, value, fee, hash });\n        this.fire('nimiq-transaction-pending', { sender, recipient, value, fee, hash });\n    }\n\n    _onTransactionMined(sender, recipient, value, fee, hash, blockHeight, timestamp) {\n        // console.log('mined:', { sender, recipient, value, fee, hash, blockHeight, timestamp });\n        this.fire('nimiq-transaction-mined', { sender, recipient, value, fee, hash, blockHeight, timestamp });\n    }\n\n    _onDifferentTabError(e) {\n        // console.log('Nimiq API is already running in a different tab:', e);\n        this.fire('nimiq-different-tab-error', e);\n    }\n\n    _onInitializationError(e) {\n        // console.log('Nimiq API could not be initialized:', e);\n        this.fire('nimiq-api-fail', e);\n    }\n\n    _onHeadChange(header) {\n        // console.log('height changed:', height);\n        this.fire('nimiq-head-change', {\n            height: header.height,\n            globalHashrate: this._globalHashrate(header.difficulty)\n        });\n    }\n\n    _onPeersChanged() {\n        // console.log('peers changed:', this._consensus.network.peerCount);\n        this.fire('nimiq-peer-count', this._consensus.network.peerCount);\n    }\n\n    static _importApi() {\n        return new Promise((resolve, reject) => {\n            let script = document.createElement('script');\n            script.type = 'text/javascript';\n            script.src = NanoNetworkApi.API_URL;\n            script.addEventListener('load', () => resolve(script), false);\n            script.addEventListener('error', () => reject(script), false);\n            document.body.appendChild(script);\n        });\n    }\n\n    fire() {\n        throw new Error('The fire() method needs to be overloaded!');\n    }\n}\n\n// todo replace master by release before release!\n\nclass Network {\n    constructor() {\n        this.connect();\n    }\n\n    async connect() {\n        const eventServer = new EventServer();\n        const network = RPC.Server(NanoNetworkApi);\n        network.fire = (event, value) => eventServer.fire(event, value);\n\n        // TODO: Init network with the GenesisConfig that we want\n        // TODO: Make the GenesisConfig configurable\n\n        await network.connect();\n    }\n}\n\nnew Network();\n\n}());\n","export default class Reflection {\n    /** @param {Object} proto\n     *\n     * @returns {Set<string>}\n     */\n    static userFunctions(proto) {\n        return new Set(Reflection._deepFunctions(proto).filter(name => {\n            return name !== 'constructor'\n                && name !== 'fire'\n                && name[0] !== '_';\n        }));\n    }\n\n    /** @param {Object} proto\n     *\n     * @returns {string[]}\n     */\n    static _deepFunctions(proto) {\n        if (!proto || proto === Object.prototype) return [];\n\n        const ownProps = Object.getOwnPropertyNames(proto);\n\n        const ownFunctions = ownProps.filter(name => {\n            const desc = Object.getOwnPropertyDescriptor(proto, name);\n            return !!desc && typeof desc.value === 'function';\n        });\n\n        const deepFunctions = Reflection._deepFunctions(Object.getPrototypeOf(proto));\n\n        return [...ownFunctions, ...deepFunctions];\n    }\n}\n","export default class Random {\n    static getRandomId() {\n        let array = new Uint32Array(1);\n        crypto.getRandomValues(array);\n        return array[0];\n    }\n}\n","import Reflection from '/libraries/secure-utils/reflection/reflection.js';\nimport Random from '/libraries/secure-utils/random/random.js';\n\nexport default class RPC {\n    /**\n     * @param {Window} targetWindow\n     * @param {string} interfaceName\n     * @param {string} [targetOrigin]\n     * @returns {Promise}\n     */\n    static async Client(targetWindow, interfaceName, targetOrigin = '*') {\n        return new Promise((resolve, reject) => {\n            let connected = false;\n\n            const interfaceListener = (message) => {\n                if (message.source !== targetWindow\n                    || message.data.status !== 'OK'\n                    || message.data.interfaceName !== interfaceName\n                    || (targetOrigin !== '*' && message.origin !== targetOrigin)) return;\n\n                self.removeEventListener('message', interfaceListener);\n\n                connected = true;\n\n                resolve( new (RPC._Client(targetWindow, targetOrigin, interfaceName, message.data.result))() );\n            };\n\n            self.addEventListener('message', interfaceListener);\n\n\n            let connectTimer;\n            const timeoutTimer = setTimeout(() => {\n                reject(new Error('Connection timeout'));\n                clearTimeout(connectTimer);\n            }, 10000);\n\n            const tryToConnect = () => {\n                if (connected) {\n                    clearTimeout(timeoutTimer);\n                    return;\n                }\n\n                try {\n                    targetWindow.postMessage({ command: 'getRpcInterface', interfaceName, id: 0 }, targetOrigin);\n                } catch (e){\n                    console.log('postMessage failed:' + e);\n                }\n                connectTimer = setTimeout(tryToConnect, 1000);\n            };\n\n            connectTimer = setTimeout(tryToConnect, 100);\n        });\n    }\n\n\n    /**\n     * @param {Window} targetWindow\n     * @param {string} interfaceName\n     * @param {array} functionNames\n     * @returns {Class}\n     * @private\n     */\n    static _Client(targetWindow, targetOrigin, interfaceName, functionNames) {\n        const Client = class {\n            constructor() {\n                this.availableMethods = functionNames;\n                // Svub: Code smell that _targetWindow and _waiting are visible outside. Todo later!\n                /** @private\n                 *  @type {Window} */\n                this._targetWindow = targetWindow;\n                this._targetOrigin = targetOrigin;\n                /** @private\n                 *  @type {Map.<number,{resolve:Function,error:Function}>} */\n                this._waiting = new Map();\n                self.addEventListener('message', this._receive.bind(this));\n            }\n\n            close() {\n                self.removeEventListener('message', this._receive.bind(this));\n            }\n\n            _receive({ source, origin, data }) {\n                // Discard all messages from unwanted sources\n                // or which are not replies\n                // or which are not from the correct interface\n                if (source !== this._targetWindow\n                    || !data.status\n                    || data.interfaceName !== interfaceName\n                    || (this._targetOrigin !== '*' && origin !== this._targetOrigin)) return;\n\n                const callback = this._waiting.get(data.id);\n\n                if (!callback) {\n                    console.log('Unknown reply', data);\n                } else {\n                    this._waiting.delete(data.id);\n\n                    if (data.status === 'OK') {\n                        callback.resolve(data.result);\n                    } else if (data.status === 'error') {\n                        const { message, stack, code } = data.result;\n                        const error = new Error(message);\n                        error.code = code;\n                        error.stack = stack;\n                        callback.error(error);\n                    }\n                }\n            }\n\n            /**\n             * @param {string} command\n             * @param {object[]} [args]\n             * @returns {Promise}\n             * @private\n             */\n            _invoke(command, args = []) {\n                return new Promise((resolve, error) => {\n                    const obj = { command, interfaceName, args, id: Random.getRandomId() };\n                    this._waiting.set(obj.id, { resolve, error });\n                    this._targetWindow.postMessage(obj, '*');\n                    // no timeout for now, as some actions require user interactions\n                    // todo maybe set timeout via parameter?\n                    //setTimeout(() => error(new Error ('request timeout')), 10000);\n                });\n            }\n        };\n\n        for (const functionName of functionNames) {\n            Client.prototype[functionName] = function (...args) {\n                return this._invoke(functionName, args);\n            };\n        }\n\n        return Client;\n    }\n\n    /**\n     * @param {Class} clazz: The class whose methods will be made available via postMessage RPC\n     * @param {boolean} useAccessControl: If set, message.source and message.origin will be passed as first two arguments to each method.\n     * @return {T extends clazz}\n     */\n    static Server(clazz, useAccessControl) {\n        return new (RPC._Server(clazz, useAccessControl))();\n    }\n\n    static _Server(clazz, useAccessControl) {\n        const Server = class extends clazz {\n            constructor() {\n                super();\n                this._name = Server.prototype.__proto__.constructor.name;\n                self.addEventListener('message', this._receive.bind(this));\n            }\n\n            close() {\n                self.removeEventListener('message', this._receive.bind(this));\n            }\n\n            _replyTo(message, status, result) {\n                message.source.postMessage({ status, result, interfaceName: this._name, id: message.data.id }, message.origin);\n            }\n\n            _receive(message) {\n                try {\n                    if (message.data.interfaceName !== this._name) return;\n\n                    let args = message.data.args || [];\n\n                    if (useAccessControl && message.data.command !== 'getRpcInterface') {\n                        // Inject calling origin to function args\n                        args = [{ callingWindow: message.source, callingOrigin: message.origin }, ...args];\n                    }\n\n                    /* deactivate this since there is no security issue and by wrapping in acl length info gets lost\n                    // Test if request calls an existing method with the right number of arguments\n                    const calledMethod = this[message.data.command];\n                    if (!calledMethod) {\n                        throw `Non-existing method ${message.data.command} called: ${message}`;\n                    }\n\n                    if (calledMethod.length < args.length) {\n                        throw `Too many arguments passed: ${message}`;\n                    }*/\n\n                    const result = this._invoke(message.data.command, args);\n\n                    if (result instanceof Promise) {\n                        result\n                            .then((finalResult) => this._replyTo(message, 'OK', finalResult))\n                            .catch(e => this._replyTo(message, 'error',\n                                e.message ? { message: e.message, stack: e.stack, code: e.code } : { message: e } ));\n                    } else {\n                        this._replyTo(message, 'OK', result);\n                    }\n                } catch (e) {\n                    this._replyTo(message, 'error',\n                        e.message ? { message: e.message, stack: e.stack, code: e.code } : { message: e } );\n                }\n            }\n\n            _invoke(command, args) {\n                return this[command].apply(this, args);\n            }\n        };\n\n        // Collect function names of the Server's interface\n        Server.prototype._rpcInterface = [];\n        for (const functionName of Reflection.userFunctions(clazz.prototype)) {\n            Server.prototype._rpcInterface.push(functionName);\n        }\n        Server.prototype._rpcInterface.push('getRpcInterface');\n\n        // Add function to retrieve the interface\n        Server.prototype['getRpcInterface'] = function() {\n            if(this.onConnected) this.onConnected.call(this);\n            return Server.prototype._rpcInterface;\n        };\n\n        return Server;\n    }\n}\n\n// TODO: Handle unload/load events (how?)\n","import RPC from './rpc.js';\n\nexport default class EventServer {\n    constructor() {\n        this._listeners = new Map();\n        const that = this;\n        RPC.Server(class EventRPCServer {\n            on({ callingWindow, callingOrigin }, event) {\n                if (!that._listeners.get(event)) {\n                    that._listeners.set(event, new Map());\n                }\n                that._listeners.get(event).set(callingWindow, callingOrigin);\n            }\n\n            off({ callingWindow, callingOrigin }, event) {\n                const eventEntry = that._listeners.get(event)\n                if (eventEntry.get(callingWindow) !== callingOrigin) return;\n\n                eventEntry.delete(callingWindow);\n                if (that._listeners.get(event).length === 0) {\n                    that._listeners.delete(event);\n                }\n            }\n\n            onConnected() {\n                that.onConnected();\n            }\n        }, true);\n    }\n\n    fire(event, value) {\n        if (!this._listeners.get(event)) return;\n\n        for (const [callingWindow, callingOrigin] of this._listeners.get(event)) {\n            callingWindow.postMessage({event, value}, callingOrigin);\n        }\n    }\n\n    onConnected() { }\n}\n","export default class NanoNetworkApi {\n\n    // static get API_URL() { return 'https://cdn.nimiq-network.com/branches/master/nimiq.js' }\n    /*\n    @asset(/dist/nimiq.js)\n    @asset(/dist/web.js)\n    @asset(/dist/worker.js)\n    @asset(/dist/worker-wasm.js)\n    @asset(/dist/worker-wasm.wasm)\n    */\n    static get API_URL() { return '/dist/nimiq.js' }\n    static get satoshis() { return 1e5 }\n\n    static getApi() {\n        this._api = this._api || new NanoNetworkApi();\n        return this._api;\n    }\n\n    constructor() {\n        this._apiInitialized = new Promise(async (resolve) => {\n            await NanoNetworkApi._importApi();\n            await Nimiq.load();\n            // setTimeout(resolve, 500);\n            resolve();\n        });\n        this._createConsensusPromise();\n\n        this._balances = new Map();\n    }\n\n    async connect() {\n        await this._apiInitialized;\n        Nimiq.GenesisConfig.bounty();\n        this._consensus = await Nimiq.Consensus.volatileNano();\n        this._consensus.on('syncing', e => this._onConsensusSyncing());\n        this._consensus.on('established', e => this.__consensusEstablished());\n        this._consensus.on('lost', e => this._consensusLost());\n\n        // this._consensus.on('sync-finished', e => console.log('consensus sync-finished'));\n        // this._consensus.on('sync-failed', e => console.log('consensus sync-failed'));\n        // this._consensus.on('sync-chain-proof', e => console.log('consensus sync-chain-proof'));\n        // this._consensus.on('verify-chain-proof', e => console.log('consensus verify-chain-proof'));\n\n        this._consensus.network.connect();\n\n        this._consensus.blockchain.on('head-changed', block => this._headChanged(block.header));\n        this._consensus.mempool.on('transaction-added', tx => this._transactionAdded(tx));\n        // this._consensus.mempool.on('transaction-expired', tx => this._transactionExpired(tx));\n        this._consensus.mempool.on('transaction-mined', (tx, header) => this._transactionMined(tx, header));\n        this._consensus.network.on('peers-changed', () => this._onPeersChanged());\n    }\n\n    async _headChanged(header) {\n        if (!this._consensus.established) return;\n        const balances = await this._getBalances([...this._balances.keys()]);\n\n        for (const [address, balance] of balances) {\n            if (this._balances.get(address) === balance) {\n                balances.delete(address);\n                continue;\n            }\n\n            this._balances.set(address, balance);\n        }\n\n        if (balances.size) this._onBalancesChanged(balances);\n\n        this._onHeadChange(header);\n    }\n\n    /**\n     * @returns {Array<Account>} An array element can be NULL if account does not exist\n     */\n    async _getAccounts(addresses, stackHeight) {\n        if (addresses.length === 0) return [];\n        await this._consensusEstablished;\n        let accounts;\n        const addressesAsAddresses = addresses.map(address => Nimiq.Address.fromUserFriendlyAddress(address));\n        try {\n            accounts = await this._consensus.getAccounts(addressesAsAddresses);\n        } catch (e) {\n            stackHeight = stackHeight || 0;\n            stackHeight++;\n            return await new Promise(resolve => {\n                const timeout = 1000 * stackHeight;\n                setTimeout(async _ => {\n                    resolve(await this._getAccounts(addresses, stackHeight));\n                }, timeout);\n                console.warn(`Could not retrieve accounts from consensus, retrying in ${timeout / 1000} s`);\n            });\n        }\n\n        return accounts;\n    }\n\n    /**\n     * @param {Array<string>} addresses\n     */\n    async _subscribeAddresses(addresses) {\n        addresses.forEach(address => this._balances.set(address, 0));\n\n        const addressesAsAddresses = addresses.map(address => Nimiq.Address.fromUserFriendlyAddress(address));\n        await this._consensusEstablished;\n        this._consensus.subscribeAccounts(addressesAsAddresses);\n    }\n\n    /**\n     * @param {Array<string>} addresses\n     * @returns {Map}\n     */\n    async _getBalances(addresses) {\n        let accounts = await this._getAccounts(addresses);\n\n        const balances = new Map();\n\n        accounts.forEach((account, i) => {\n            const address = addresses[i];\n            const balance = account ? account.balance / NanoNetworkApi.satoshis : 0 ;\n            balances.set(address, balance);\n        });\n\n        return balances;\n    }\n\n    /**\n     * @param {string} address\n     * @param {Map} [knownReceipts] A map with the tx hash as key and the blockhash as value\n     * @param {uint} [fromHeight]\n     */\n    async _requestTransactionHistory(address, knownReceipts = new Map(), fromHeight = 0) {\n        await this._consensusEstablished;\n        address = Nimiq.Address.fromUserFriendlyAddress(address);\n\n        // Inpired by Nimiq.BaseConsensus._requestTransactionHistory()\n\n        // 1. Get transaction receipts.\n        let receipts = await this._consensus._requestTransactionReceipts(address);\n        // console.log(`Received ${receipts.length} receipts from the network.`);\n\n        // 2 Filter out known receipts.\n        const knownTxHashes = [...knownReceipts.keys()];\n\n        receipts = receipts.filter(receipt => {\n            if (receipt.blockHeight < fromHeight) return false;\n\n            const hash = receipt.transactionHash.toBase64();\n\n            // Known transaction\n            if (knownTxHashes.includes(hash)) {\n                // Check if block has changed\n                return receipt.blockHash.toBase64() !== knownReceipts.get(hash);\n            }\n\n            // Unknown transaction\n            return true;\n        });\n        // console.log(`Reduced to ${receipts.length} unknown receipts.`);\n\n        // FIXME TODO: Check for tx that have been removed from the blockchain!\n\n        // 3. Request proofs for missing blocks.\n        /** @type {Array.<Promise.<Block>>} */\n        const blockRequests = [];\n        let lastBlockHash = null;\n        for (const receipt of receipts) {\n            if (!receipt.blockHash.equals(lastBlockHash)) {\n                // eslint-disable-next-line no-await-in-loop\n                const block = await this._consensus._blockchain.getBlock(receipt.blockHash);\n                if (block) {\n                    blockRequests.push(Promise.resolve(block));\n                } else {\n                    const request = this._consensus._requestBlockProof(receipt.blockHash, receipt.blockHeight)\n                        .catch(e => console.error(NanoNetworkApi, `Failed to retrieve proof for block ${receipt.blockHash}`\n                            + ` (${e.message || e}) - transaction history may be incomplete`));\n                    blockRequests.push(request);\n                }\n\n                lastBlockHash = receipt.blockHash;\n            }\n        }\n        const blocks = await Promise.all(blockRequests);\n\n        // 4. Request transaction proofs.\n        const transactionRequests = [];\n        for (const block of blocks) {\n            if (!block) continue;\n\n            const request = this._consensus._requestTransactionsProof([address], block)\n                .then(txs => txs.map(tx => ({ transaction: tx, header: block.header })))\n                .catch(e => console.error(NanoNetworkApi, `Failed to retrieve transactions for block ${block.hash}`\n                    + ` (${e.message || e}) - transaction history may be incomplete`));\n            transactionRequests.push(request);\n        }\n\n        const transactions = await Promise.all(transactionRequests);\n        return transactions\n            .reduce((flat, it) => it ? flat.concat(it) : flat, [])\n            .sort((a, b) => a.header.height - b.header.height);\n    }\n\n    __consensusEstablished() {\n        this._consensusEstablishedResolver();\n        this._headChanged(this._consensus.blockchain.head);\n        this._onConsensusEstablished();\n    }\n\n    _consensusLost() {\n        this._createConsensusPromise();\n        this._onConsensusLost();\n    }\n\n    _transactionAdded(tx) {\n        const recipientAddr = tx.recipient.toUserFriendlyAddress();\n        const senderAddr = tx.sender.toUserFriendlyAddress();\n        const trackedAddresses = new Set(this._balances.keys());\n\n        if (trackedAddresses.has(senderAddr) || trackedAddresses.has(recipientAddr)) {\n            this._onTransactionPending(senderAddr, recipientAddr, tx.value / NanoNetworkApi.satoshis, tx.fee / NanoNetworkApi.satoshis, tx.hash().toBase64());\n        }\n    }\n\n    _transactionMined(tx, header) {\n        const recipientAddr = tx.recipient.toUserFriendlyAddress();\n        const senderAddr = tx.sender.toUserFriendlyAddress();\n        const trackedAddresses = new Set(this._balances.keys());\n\n        if (trackedAddresses.has(recipientAddr) || trackedAddresses.has(senderAddr)) {\n            this._onTransactionMined(senderAddr, recipientAddr, tx.value / NanoNetworkApi.satoshis, tx.fee / NanoNetworkApi.satoshis, tx.hash().toBase64(), header.height, header.timestamp);\n        }\n    }\n\n    _createConsensusPromise() {\n        this._consensusEstablished = new Promise(resolve => {\n            this._consensusEstablishedResolver = resolve;\n        });\n    }\n\n    _globalHashrate(difficulty) {\n        return Math.round(difficulty * Math.pow(2, 16) / Nimiq.Policy.BLOCK_TIME);\n    }\n\n    /*\n        Public API\n\n        @param {Object} obj: {\n            sender: <user friendly address>,\n            senderPubKey: <serialized public key>,\n            recipient: <user friendly address>,\n            value: <value in NIM>,\n            fee: <fee in NIM>,\n            validityStartHeight: <integer>,\n            signature: <serialized signature>\n        }\n    */\n    async relayTransaction(obj) {\n        await this._consensusEstablished;\n        const senderPubKey = Nimiq.PublicKey.unserialize(Nimiq.SerialBuffer.from(obj.senderPubKey));\n        const recipientAddr = Nimiq.Address.fromUserFriendlyAddress(obj.recipient);\n        const value = Nimiq.Policy.coinsToSatoshis(obj.value);\n        const fee = Nimiq.Policy.coinsToSatoshis(obj.fee);\n        const validityStartHeight = parseInt(obj.validityStartHeight);\n        const signature = Nimiq.Signature.unserialize(Nimiq.SerialBuffer.from(obj.signature));\n\n        const tx = new Nimiq.BasicTransaction(senderPubKey, recipientAddr, value, fee, validityStartHeight, signature);\n\n        return this._consensus.relayTransaction(tx);\n    }\n\n    /**\n     * @param {string|Array<string>} addresses\n     */\n    async subscribe(addresses) {\n        if (!(addresses instanceof Array)) addresses = [addresses];\n\n        this._subscribeAddresses(addresses);\n\n        const balances = await this._getBalances(addresses);\n        for (const [address, balance] of balances) { this._balances.set(address, balance); }\n\n        this._onBalancesChanged(balances);\n    }\n\n    /**\n     * @param {string|Array<string>} addresses\n     * @returns {Map}\n     */\n    getBalance(addresses) {\n        if (!(addresses instanceof Array)) addresses = [addresses];\n\n        const balances = this._getBalances(addresses);\n        for (const [address, balance] of balances) { this._balances.set(address, balance); }\n\n        return balances;\n    }\n\n    async getAccountTypeString(address) {\n        const account = (await this._getAccounts([address]))[0];\n\n        if (!account) return 'basic';\n\n        // See Nimiq.Account.Type\n        switch (account.type) {\n            case Nimiq.Account.Type.BASIC: return 'basic';\n            case Nimiq.Account.Type.VESTING: return 'vesting';\n            case Nimiq.Account.Type.HTLC: return 'htlc';\n            default: return false;\n        }\n    }\n\n    async requestTransactionHistory(addresses, knownReceipts, fromHeight) {\n        if (!(addresses instanceof Array)) addresses = [addresses];\n\n        let txs = await Promise.all(addresses.map(address => this._requestTransactionHistory(address, knownReceipts, fromHeight)));\n\n        // txs is an array of arrays of objects, which have the format {transaction: Nimiq.Transaction, header: Nimiq.BlockHeader}\n        // We need to reduce this to usable simple tx objects\n\n        // First, reduce\n        txs = txs.reduce((flat, it) => it ? flat.concat(it) : flat, []);\n\n        // Then map to simple objects\n        txs = txs.map(tx => ({\n            sender: tx.transaction.sender.toUserFriendlyAddress(),\n            recipient: tx.transaction.recipient.toUserFriendlyAddress(),\n            value: tx.transaction.value / NanoNetworkApi.satoshis,\n            fee: tx.transaction.fee / NanoNetworkApi.satoshis,\n            hash: tx.transaction.hash().toBase64(),\n            blockHeight: tx.header.height,\n            blockHash: tx.header.hash().toBase64(),\n            timestamp: tx.header.timestamp\n        }));\n\n        // Finally, sort the array\n        // return txs.sort((a, b) => a.blockHeight - b.blockHeight);\n        return txs; // Sorting is done in transaction-redux\n    }\n\n    async getGenesisVestingContracts() {\n        await this._apiInitialized;\n        const accounts = [];\n        const buf = Nimiq.BufferUtils.fromBase64(Nimiq.GenesisConfig.GENESIS_ACCOUNTS);\n        const count = buf.readUint16();\n        for (let i = 0; i < count; i++) {\n            const address = Nimiq.Address.unserialize(buf);\n            const account = Nimiq.Account.unserialize(buf);\n\n            if (account.type === 1) {\n                accounts.push({\n                    address: address.toUserFriendlyAddress(),\n                    // balance: account.balance / NanoNetworkApi.satoshis,\n                    owner: account.owner.toUserFriendlyAddress(),\n                    start: account.vestingStart,\n                    stepAmount: account.vestingStepAmount / NanoNetworkApi.satoshis,\n                    stepBlocks: account.vestingStepBlocks,\n                    totalAmount: account.vestingTotalAmount / NanoNetworkApi.satoshis\n                });\n            }\n        }\n        return accounts;\n    }\n\n    _onInitialized() {\n        // console.log('Nimiq API ready to use');\n        this.fire('nimiq-api-ready');\n    }\n\n    _onConsensusSyncing() {\n        // console.log('consensus syncing');\n        this.fire('nimiq-consensus-syncing');\n    }\n\n    _onConsensusEstablished() {\n        // console.log('consensus established');\n        this.fire('nimiq-consensus-established');\n    }\n\n    _onConsensusLost() {\n        // console.log('consensus lost');\n        this.fire('nimiq-consensus-lost');\n    }\n\n    _onBalancesChanged(balances) {\n        // console.log('new balances:', balances);\n        this.fire('nimiq-balances', balances);\n    }\n\n    _onTransactionPending(sender, recipient, value, fee, hash) {\n        // console.log('pending:', { sender, recipient, value, fee, hash });\n        this.fire('nimiq-transaction-pending', { sender, recipient, value, fee, hash });\n    }\n\n    _onTransactionMined(sender, recipient, value, fee, hash, blockHeight, timestamp) {\n        // console.log('mined:', { sender, recipient, value, fee, hash, blockHeight, timestamp });\n        this.fire('nimiq-transaction-mined', { sender, recipient, value, fee, hash, blockHeight, timestamp });\n    }\n\n    _onDifferentTabError(e) {\n        // console.log('Nimiq API is already running in a different tab:', e);\n        this.fire('nimiq-different-tab-error', e);\n    }\n\n    _onInitializationError(e) {\n        // console.log('Nimiq API could not be initialized:', e);\n        this.fire('nimiq-api-fail', e);\n    }\n\n    _onHeadChange(header) {\n        // console.log('height changed:', height);\n        this.fire('nimiq-head-change', {\n            height: header.height,\n            globalHashrate: this._globalHashrate(header.difficulty)\n        });\n    }\n\n    _onPeersChanged() {\n        // console.log('peers changed:', this._consensus.network.peerCount);\n        this.fire('nimiq-peer-count', this._consensus.network.peerCount);\n    }\n\n    static _importApi() {\n        return new Promise((resolve, reject) => {\n            let script = document.createElement('script');\n            script.type = 'text/javascript';\n            script.src = NanoNetworkApi.API_URL;\n            script.addEventListener('load', () => resolve(script), false);\n            script.addEventListener('error', () => reject(script), false);\n            document.body.appendChild(script);\n        });\n    }\n\n    fire() {\n        throw new Error('The fire() method needs to be overloaded!');\n    }\n}\n\n// todo replace master by release before release!\n","import { EventServer, RPC } from '/libraries/boruca-messaging/src/boruca.js';\nimport NanoNetworkApi from '/libraries/nano-api/nano-network-api.js';\n\nclass Network {\n    constructor() {\n        this.connect();\n    }\n\n    async connect() {\n        const eventServer = new EventServer();\n        const network = RPC.Server(NanoNetworkApi);\n        network.fire = (event, value) => eventServer.fire(event, value);\n\n        // TODO: Init network with the GenesisConfig that we want\n        // TODO: Make the GenesisConfig configurable\n\n        await network.connect();\n    }\n}\n\nnew Network();\n"]}